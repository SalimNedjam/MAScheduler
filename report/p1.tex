\section*{Problématique}

Le problème se présente quand plusieurs processus souhaitent accéder à une même
ressource critique. En effet, considérons un processus A (de haute priorité) qui
se met à attendre un processus B (moins propriétaire), ce dernier peut se faire déscheduler
par un processus C dont la priorité est: 

Pri(A) $>$ Pri(C) $>$ Pri(B), cela va retarder
l'élection du processus A car le processus B qui détient la ressource 
évoluera lentement. 

Il est donc important de faire passer en priorité dans les 
élections le processus détenant cette section tout en respectant la prévalence
des autres processus indépendants pour respecter la sémantique du CFS 
(Completly Fair scheduler).
\\

Pour résoudre ce problème il a fallu dans un premier temps permettre au
kernel de connaître l'identité du processus propriétaire du verrou.
Ensuite le scheduler devait utiliser cette information et agir en conséquence.
\\

\section*{Glibc et mutex}
La Glibc offre un panel de fonctionnalités. 
Celle des verrous (mutex) nous intéresse particulièrement: elle permet 
d'abstraire aux programmeurs l'utilisation complexe des verrous côté kernel.
\\

Il existe 4 types de mutex proposés à l'utilisateur :
\begin{enumerate}
	\item TIMED: type par défaut, prend le verrou de manière bloquante.
	\item RECURSIVE: ne tente pas de prendre le verrou si celui-ci est
	déjà détenu par le processus courant.
	\item ADAPTIVE: correspond à la méthode de prise de verrou 'trylock',
	au bout d'un certain nombre d'échec la prise de verrou se fait
	bloquante.
	\item ERRORCHECK: prend le verrou ne manière brutale en évitant
	simplement les problèmes de contention.
\end{enumerate}
Le choix du type de mutex se fait lors de l'initialisation du verrou.
\\
On peut combiner ces 4 types externes avec des types internes qui permettent de
modifier le comportement du verrou jusqu'au kernel:
\newpage
\begin{enumerate}
	\item ROBUST: type par défaut, si le propriétaire du verrou meurt sans
	le relâcher la prochaine demande à se verrou sera accepté sans appel
	système.
	\item PI (Priority Inheritance): la priorité du processus détenant le
	verrou est augmenté à la plus grande priorité parmi les processus
	bloqués sur le verrou.
	\item PP (Priority Protect): le processus à sa priorité déterminé par
	sa configuration grâce à 'priority ceiling'.
\end{enumerate}
Les types ROBUST et PI insère le \textit{pid} du propriétaire du verrou
directement dans la valeur du verrou. Ainsi lors des appels systèmes le kernel
peut connaître le \textit{pid} du propriétaire du verrou avec une simple
opération de flag sur la valeur passée.
\\

En tenant compte de ces éléments on peut donc en déduire que la modification 
de la partie Glibc n'est pas nécessaire. En effet le \textit{pid} du 
propriétaire du verrou étant déjà communiqué il nous suffit de le récupérer 
côté kernel. Ainsi cela permet à notre futur solution de ne pas dépendre de 
modification ou de décoration d'une fonctionnalité de la Glibc
\newpage
\section*{Kernel et futex}
La Glibc communique avec le kernel à travers des appels systèmes, elle fournit 
en paramètre l'adresse virtuelle de l'espace utilisateur qui contient la 
valeur du lock.
\\

Cette dernière est convertie par une fonction de hashage en clé unique qui 
identifie un futex donné, elle est ensuite utilisée dans un bucket pour lister
tous les processus en attente d'un futex donnés.
\\

Pour permettre au kernel de bien suivre l'évolution du possesseur du lock, Il a
fallu crée une structure \verb|futex_state| pour gérer l'état d'un futex, elle se
présente comme ci-dessous:
\begin{lstlisting}
	struct futex_state {
		struct list_head list;
		struct rt_mutex mutex;
		struct task_struct *owner;
		atomic_t refcount;
		union futex_key *key;
	};

\end{lstlisting}
cette structure contient toutes les informations nécessaires au scheduler pour 
choisir la bonne cible.
\\

Pour que les informations transmises au scheduler reflète l'état exact du futex
à un instant \textit{t}, il faut que la structure \verb|futex_state| soit mise à jour
à chaque changement de l'état du futex. Ainsi, chaque processus avant de 
s'endormir sur un futex indique dans un champ de sa structure task l'adresse de 
la structure \verb|futex_state| du futex sur lequel il va s'endormir.
\\

Par conséquent chaque processus après avoir manipulé le futex 
devra chercher dans une liste chaînée la structure \verb|futex_state| associée au 
futex et la mettre à jour avec la valeur courante du lock. Ainsi à tout moment 
le scheduler peut savoir sur quel futex un processus prioritaire et endormi 
et quel est le processus qui détient ce futex.