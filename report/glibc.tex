\section*{Glibc et mutex}
La Glibc offre un panel de fonctionnalités. 
Celle des verrous (mutex) nous intéresse particulièrement: elle permet 
d'abstraire aux programmeurs l'utilisation complexe des verrous côté kernel.
\\

Il existe 4 types de mutex proposés à l'utilisateur :
\begin{enumerate}
	\item TIMED: type par défaut, prend le verrou de manière bloquante.
	\item RECURSIVE: ne tente pas de prendre le verrou si celui-ci est
	déjà détenu par le processus courant.
	\item ADAPTIVE: correspond à la méthode de prise de verrou 'trylock',
	au bout d'un certain nombre d'échec la prise de verrou se fait
	bloquante.
	\item ERRORCHECK: prend le verrou ne manière brutale en évitant
	simplement les problèmes de contention.
\end{enumerate}
Le choix du type de mutex se fait lors de l'initialisation du verrou.
\\
On peut combiner ces 4 types externes avec des types internes qui permettent de
modifier le comportement du verrou jusqu'au kernel:

\begin{enumerate}
	\item ROBUST: type par défaut, si le propriétaire du verrou meurt sans
	le relâcher la prochaine demande à se verrou sera accepté sans appel
	système.
	\item PI (Priority Inheritance): la priorité du processus détenant le
	verrou est augmenté à la plus grande priorité parmi les processus
	bloqués sur le verrou.
	\item PP (Priority Protect): le processus à sa priorité déterminé par
	sa configuration grâce à 'priority ceiling'.
\end{enumerate}
Les types ROBUST et PI insère le \textit{pid} du propriétaire du verrou
directement dans la valeur du verrou. Ainsi lors des appels systèmes le kernel
peut connaître le \textit{pid} du propriétaire du verrou avec une simple
opération de flag sur la valeur passée.
\\

En tenant compte de ces éléments on peut donc en déduire que la modification 
de la partie Glibc n'est pas nécessaire. En effet le \textit{pid} du 
propriétaire du verrou étant déjà communiqué il nous suffit de le récupérer 
côté kernel. Ainsi cela permet à notre futur solution de ne pas dépendre de 
modification ou de décoration d'une fonctionnalité de la Glibc et ainsi d'éviter 
qu'il y ai un cycle de dépendance entre la Glibc et le kernel.