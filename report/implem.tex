\section*{Implémentation}

Pour permettre au kernel de suivre l'évolution du possesseur du lock, Il a
fallu créer une structure \verb|futex_state| pour gérer l'état d'un futex. 
Voici la structure :
\begin{lstlisting}
struct futex_state {
	struct list_head list;
	struct rt_mutex mutex;
	struct task_struct *owner;
	struct kref refcount;
	union futex_key *key;
};
\end{lstlisting}

Cette structure contient toutes les informations nécessaires au scheduler pour 
choisir la bonne cible.
\\

Un mutex dans la structure est ici nécessaire, permettant d'éviter les accès concurrents lors de la manipulation de celle-ci. Pour protéger la suppression des structures, et ainsi éviter de libérer une zone mémoire déjà utilisée par un autre thread, nous utilisons des \verb|kref|. Ce compteur de référence va permettre de libérer les espaces mémoires dès que le nombre de références sur une structure \verb|futext_state| atteint zéro.

Dans notre cas l'utilisation des shrinker, pour optimiser l'utilisation
mémoire, n'est pas possible. En effet, on ne peut pas se permettre de supprimer ou bien de libérer une référence d'un objet en cours d'utilisation, cela peut compromettre tout le mécanisme de verrouillage des futex.
\\

Pour que les informations transmises reflètent l'état exact du futex
à un instant \textit{t}, il faut que la structure \verb|futex_state| soit mise à jour
à chaque changement du propriétaire du futex. Ainsi, chaque processus avant de 
s'endormir sur un futex indique dans un champ de sa structure task l'adresse de 
la structure \verb|futex_state| du futex sur lequel il va s'endormir.
\\

Par conséquent, chaque processus après avoir manipulé le futex 
devra chercher dans une liste chaînée la structure \verb|futex_state| associée au 
futex et la mettre à jour avec la valeur courante du lock. Ainsi, à tout moment 
le kernel peut savoir sur quel futex un processus prioritaire est endormi et quel
est le processus qui détient ce futex.