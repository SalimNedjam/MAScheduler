\section{Implémentation}

Notre choix d'implémentation a donc été de ne pas modifier directement le code du scheduler (\verb|kernel/sched/fair.c|), mais d'ajouter notre mécanisme lors de la prise de
verrou dans le code
du futex (\verb|kernel/futex.c|) et d'agir directement sur les priorités des tâches.

L'ensemble de nos modifications dans le kernel on été préfixé par un commentaire \verb|MAS code|.

\subsection{État du futex}

La première étape à donc été de créer un mécanisme permettant au kernel de pouvoir facilement
suivre l'évolution du propriétaire d'un futex.

\subsubsection{Structure}

Nous avons donc ajouté une structure \verb|futex_state| qui représente l'état d'un
futex:

\begin{lstlisting}
struct futex_state {
	struct list_head list_global;
	struct list_head list_local;
	struct task_struct *owner;
	struct rt_mutex mutex;
	struct kref refcount;
	int load;
	union futex_key *key;
};
\end{lstlisting}

Les champs sont les suivants:
\begin{itemize}
	\item \verb|list_global| et \verb|list_local| permettent respectivement de
	créer un chaînage global entre tous les futex, et local entre les futex d'un même
	propriétaire.
	\item \verb|owner| est une référence sur la \verb|task_struct| du propriétaire du futex.
	
	\item \verb|mutex| permet d'éviter les accès concurrents lors de la manipulation de
	la structure.
	
	\item \verb|kref| est un compteur de référence pour protéger la suppression
	des structures, et ainsi éviter de libérer la structure utilisée ailleurs.
	
	\item \verb|load| est le poids associé au futex.
	
	\item \verb|key| est la clé du futex, permettant d'identifier la structure pour un 
	futex donné.
\end{itemize}
\hspace{1cm}

Une modification sur la structure \verb|task_struct| a été nécessaire:

\begin{lstlisting}
struct task_struct {
	...
	struct list_head futex_state_list;
	struct mutex futex_state_lock;
	struct futex_state *waiting_futex_state;
	...
}
\end{lstlisting}

Les champs ajoutés sont les suivants:
\begin{itemize}
	\item \verb|futex_state_list| est la liste locale, elle rassemble l'ensemble des
	\verb|futex_state| que la tâche détient et sur lesquels d'autres tâches attendent.
	
	\item \verb|futex_state_lock| est un verrou pour la manipulation de la liste locale.
	
	\item \verb|waiting_futex_state| est un pointeur vers le \verb|futex_state| sur lequel
	la tâche attend.
\end{itemize}

\subsubsection{Shrinker}

Les shrinker permettent une optimisation mémoire.
Dans notre cas leur utilisation n'est pas possible. En effet, on ne peut pas se permettre de supprimer ou bien de libérer une référence d'une structure \verb|futex_state| en cours d'utilisation, cela peut compromettre tout le mécanisme de verrouillage des futex.


\subsubsection{Fonctionnement}

Pour que les informations transmises reflètent l'état exact du futex
à un instant \textit{t}, il faut que la structure \verb|futex_state| soit mise à jour
à chaque changement du propriétaire du futex.
Ainsi, quand une tâche souhaite prendre un futex déjà détenu un \verb|futex_state|
est créé si

Par conséquent, chaque processus après avoir manipulé le futex 
devra chercher dans une liste chaînée la structure \verb|futex_state| associée au 
futex et la mettre à jour avec la valeur courante du verrou. Ainsi, à tout moment 
le kernel peut savoir sur quel futex un processus prioritaire est endormi et quel
est le processus qui détient ce futex.